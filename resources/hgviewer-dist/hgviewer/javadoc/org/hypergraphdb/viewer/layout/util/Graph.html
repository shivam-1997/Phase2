<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_21) on Thu May 20 17:18:16 EDT 2010 -->
<TITLE>
Graph
</TITLE>

<META NAME="keywords" CONTENT="org.hypergraphdb.viewer.layout.util.Graph class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Graph";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Coordinates.html" title="class in org.hypergraphdb.viewer.layout.util"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.Edge.html" title="class in org.hypergraphdb.viewer.layout.util"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?org/hypergraphdb/viewer/layout/util/Graph.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Graph.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.hypergraphdb.viewer.layout.util</FONT>
<BR>
Class Graph</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>org.hypergraphdb.viewer.layout.util.Graph</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Graph</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Performs transformations and calculations on graphs.
 This class accepts graphs in an abstract representation. Nodes
 are indexed with integers, beginning with 0. Edges are represented
 with instances of the <CODE>csplugins.hierarchicallayout.FEdge</CODE>
 class, which holds a (from, to) pair of integers.
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.Edge.html" title="class in org.hypergraphdb.viewer.layout.util">Graph.Edge</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Holds a (from, to) pair of integers representing an edge.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#Graph(int, org.hypergraphdb.viewer.layout.util.Graph.Edge[])">Graph</A></B>(int&nbsp;a_nodecount,
      <A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.Edge.html" title="class in org.hypergraphdb.viewer.layout.util">Graph.Edge</A>[]&nbsp;a_edge)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Build a graph from a supplied FEdge array.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#Graph(java.io.Reader)">Graph</A></B>(java.io.Reader&nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Build a graph from a stream.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#componentIndex()">componentIndex</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine node membership in the set of connected components.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getCycleEliminationVertexPriority()">getCycleEliminationVertexPriority</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Determine an ordering of nodes used to eliminate cycles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getEdgecount()">getEdgecount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accessor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getGraphWithoutCycles(int[])">getGraphWithoutCycles</A></B>(int[]&nbsp;cycleEliminationPriority)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a graph where all "left" edges are reversed (according to provided node ordering).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getGraphWithoutMultipleEdges()">getGraphWithoutMultipleEdges</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a graph which filters out duplicate edges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getGraphWithoutOneOrTwoCycles()">getGraphWithoutOneOrTwoCycles</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a graph which filters out short (length 1 or 2) cycles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getHorizontalPosition(int[])">getHorizontalPosition</A></B>(int[]&nbsp;vertexLayer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pick Horizontal coordinates within layers for a layered graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getNodecount()">getNodecount</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Accessor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getReducedGraph()">getReducedGraph</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a graph which is the transitive reduction of the current graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getReducedGraph(int[])">getReducedGraph</A></B>(int[]&nbsp;topologicalOrder)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Make a graph which is the transitive reduction of the current graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getVertexLayers()">getVertexLayers</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return an array of layer assignments for the nodes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#hasEdge(int, int)">hasEdge</A></B>(int&nbsp;edgeFrom,
        int&nbsp;edgeTo)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Query to test whether an edge exists.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#main(java.lang.String[])">main</A></B>(java.lang.String[]&nbsp;args)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read a graph representation from stdin and write out the computed Layer
 assignment and Horizontal position within layer of each node of each
 component.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#orderedSetComparison(int[], int[])">orderedSetComparison</A></B>(int[]&nbsp;set1,
                     int[]&nbsp;set2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compare two sets of integers lexicographically.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#partition(int[], int[])">partition</A></B>(int[]&nbsp;partitionIndex,
          int[]&nbsp;nodeRenumber)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create an array of Graphs by partitioning this graph.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Human readable description of graph representation.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Graph(int, org.hypergraphdb.viewer.layout.util.Graph.Edge[])"><!-- --></A><H3>
Graph</H3>
<PRE>
public <B>Graph</B>(int&nbsp;a_nodecount,
             <A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.Edge.html" title="class in org.hypergraphdb.viewer.layout.util">Graph.Edge</A>[]&nbsp;a_edge)</PRE>
<DL>
<DD>Build a graph from a supplied FEdge array.
 Nodes must be consecutively indexed beginning with zero.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>a_nodecount</CODE> - The total number of nodes in the graph<DD><CODE>a_edge</CODE> - An array of all edges in the graph (each edge holds the source and destination node's indicies)
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - If any edge refers to an out of range node</DL>
</DL>
<HR>

<A NAME="Graph(java.io.Reader)"><!-- --></A><H3>
Graph</H3>
<PRE>
public <B>Graph</B>(java.io.Reader&nbsp;r)
      throws java.io.IOException</PRE>
<DL>
<DD>Build a graph from a stream.
 The input stream will be read and parsed in the following format:
 On the first line is an integer indicating the number of nodes in the graph.
 This is followed by one line per edge containing two integers: the edge
 source (where nodes are indexed sequentially starting from zero), and the
 edge destination. These two values are spearated by whitespace. Then there
 is a terminal line containing only a period character "." <br>
 Unavailable or badly formed files will cause exceptions to be thrown
 (including NumberFormatExceptions)
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>r</CODE> - The reader of the input stream from which to read the graph data.
<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE> - if trouble is encountered reading the file
<DD><CODE>java.lang.NumberFormatException</CODE> - if any value in the input does not parse to an integer</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Human readable description of graph representation. Prints a node count line
 followed by the edge endpoint (one per line).
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>Human readable graph description in string form</DL>
</DD>
</DL>
<HR>

<A NAME="getNodecount()"><!-- --></A><H3>
getNodecount</H3>
<PRE>
public int <B>getNodecount</B>()</PRE>
<DL>
<DD>Accessor.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>total number of nodes in graph</DL>
</DD>
</DL>
<HR>

<A NAME="getEdgecount()"><!-- --></A><H3>
getEdgecount</H3>
<PRE>
public int <B>getEdgecount</B>()</PRE>
<DL>
<DD>Accessor.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>total number of edges in graph</DL>
</DD>
</DL>
<HR>

<A NAME="hasEdge(int, int)"><!-- --></A><H3>
hasEdge</H3>
<PRE>
public boolean <B>hasEdge</B>(int&nbsp;edgeFrom,
                       int&nbsp;edgeTo)</PRE>
<DL>
<DD>Query to test whether an edge exists.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>edgeFrom</CODE> - node index for the origin<DD><CODE>edgeTo</CODE> - node index for the destination
<DT><B>Returns:</B><DD>True if the queried edge is in the graph</DL>
</DD>
</DL>
<HR>

<A NAME="getGraphWithoutOneOrTwoCycles()"><!-- --></A><H3>
getGraphWithoutOneOrTwoCycles</H3>
<PRE>
public <A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</A> <B>getGraphWithoutOneOrTwoCycles</B>()</PRE>
<DL>
<DD>Make a graph which filters out short (length 1 or 2) cycles.
 Generates a new graph object which is the same is the current graph except
 that all edges which begin and end at the same node (loops) or edges which
 are an inverted instance of some other edge in the graph (a,b); (b,a)
 are filtered out.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a graph without cycles of length one or edges which used to
 be part of a cycle of length two.</DL>
</DD>
</DL>
<HR>

<A NAME="getGraphWithoutMultipleEdges()"><!-- --></A><H3>
getGraphWithoutMultipleEdges</H3>
<PRE>
public <A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</A> <B>getGraphWithoutMultipleEdges</B>()</PRE>
<DL>
<DD>Make a graph which filters out duplicate edges.
 Generates a new graph object which is the same is the current graph except
 that if there are several duplicate edges (same source and target), all
 but one of each set of duplicates is filtered out.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a graph without duplicate edges</DL>
</DD>
</DL>
<HR>

<A NAME="componentIndex()"><!-- --></A><H3>
componentIndex</H3>
<PRE>
public int[] <B>componentIndex</B>()</PRE>
<DL>
<DD>Determine node membership in the set of connected components.
 Components are detected and numbered. Each node is assigned an integer number
 which corresponds to the component which it is a member of. Components are
 numbered consecutively, beginning with 0. These numbers are returned in an
 array, whose length is equal to nodecount.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>An array of integer component numbers - one for each node in this graph.</DL>
</DD>
</DL>
<HR>

<A NAME="partition(int[], int[])"><!-- --></A><H3>
partition</H3>
<PRE>
public <A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</A>[] <B>partition</B>(int[]&nbsp;partitionIndex,
                         int[]&nbsp;nodeRenumber)</PRE>
<DL>
<DD>Create an array of Graphs by partitioning this graph.
 This method takes an array of integers equal in length to nodecount.
 Each element of the array specifies which subgraph the corresponding
 node should belong to. Subgraphs are numbered beginning with zero.
 Every node is put in exactly one subgraph, and
 the set of subgraphs are returned. The index number of each node is
 recalculated as it is added to its subgraph. This renumbering is returned
 in an array passed in as an argument (nodeRenumber). The elements of
 this array will hold the new index number of each node as it appears
 in its corresponding subgraph.<br>
 Edges' source and destination values are modified to maintain the
 appropriate topology. Edges which span different subgraphs are
 deleted.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>partitionIndex</CODE> - A subgraph index for each node in the graph.<DD><CODE>nodeRenumber</CODE> - An array which is passed back to the caller
 containing the new index number of each node as it sits in its
 subgraph.
<DT><B>Returns:</B><DD>An array of graphs containing the nodes directed to each
 subgraph according to the indicies in partitionIndex.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the size of either argument
 array is incorrect (!= nodecount)</DL>
</DD>
</DL>
<HR>

<A NAME="getCycleEliminationVertexPriority()"><!-- --></A><H3>
getCycleEliminationVertexPriority</H3>
<PRE>
public int[] <B>getCycleEliminationVertexPriority</B>()</PRE>
<DL>
<DD>Determine an ordering of nodes used to eliminate cycles.
 This is an implementation of the "Greedy-Cycle-Removal"
 algorithm presented by Sugiyama et al. in chapter 9 of
 "Graph Drawing" by Di Battista et al. <br>
 The basic appraach is that all nodes are examined and
 nodes which are sinks are removed from the graph and
 added to the end of the order, and nodes which are
 sources are removed and added to the beginning of the
 order. If there are no sources or sinks, the node with
 the greatest difference between outgoing and incoming
 edges is added to the beginning of the list. Removing
 nodes from the graph creates new sources and sinks,
 and through iteration an order is computed. <br>
 Note: during this computation, nodes are removed from
 a temporary copy of the graph; no change happens to
 the current graph. Also, the temporary copy is filtered
 of short cycles (length 1 or 2 cycles) and transitive
 edges.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>An array of integers which represents an ordered list
 of nodes. The elements which are closer to the beginning of the
 array are indecies of nodes which are more "sourcelike". Those
 closer to the end of the array are more "sinklike". The intention
 is that this ordering will be used to eliminate cycles by reversing
 the direction of any edges which oppose the implied flow from
 sources to sinks.</DL>
</DD>
</DL>
<HR>

<A NAME="getGraphWithoutCycles(int[])"><!-- --></A><H3>
getGraphWithoutCycles</H3>
<PRE>
public <A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</A> <B>getGraphWithoutCycles</B>(int[]&nbsp;cycleEliminationPriority)</PRE>
<DL>
<DD>Make a graph where all "left" edges are reversed (according to provided node ordering).
 A left edge is one which begins at a node which is later
 in the provided order than the edge's destination.
 A new Graph object which is thereby free of cycles is
 returned.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cycleEliminationPriority</CODE> - an ordering of node indecies.
 Nodes near the beginning are considered more "sourcelike",
 while those towards the end are condiered more "sinklike".
<DT><B>Returns:</B><DD>A Graph which is similar to the current graph, but
 which has no cycles due to the reversal of left edges.</DL>
</DD>
</DL>
<HR>

<A NAME="getReducedGraph(int[])"><!-- --></A><H3>
getReducedGraph</H3>
<PRE>
public <A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</A> <B>getReducedGraph</B>(int[]&nbsp;topologicalOrder)</PRE>
<DL>
<DD>Make a graph which is the transitive reduction of the current graph.
 A transitive edge is one where some other path exists from the
 edge's source to its destination. Using the provided topological
 ordedring of nodes, this method efficiently preforms the reduction.
 The heart of the algorithm is that at each node, the child which
 has the highest position in the topological order cannot be a
 transitive edge. If we know the list of descendants of that child,
 then we know if the second child (in the topological order) is
 connected by a transitive edge or not. By recursively updating
 the lists of descendants of a node, this process continues until
 all children are examined, at which point we know the full list
 of the examined node's descendants, which can be passeed up to
 the node's parents, allowing the recursion. <br>
 Note: this method can only be called on a graph which is acyclic,
 otherwise a RuntimeException is thrown.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>topologicalOrder</CODE> - an ordering of node indecies such that
 there are no edges from a node lower in the order to a node higher
 in the ordedr.
<DT><B>Returns:</B><DD>A Graph which is the transitive reduction of the current
 graph.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the size of topological order
 is not equal to nodecount.
<DD><CODE>java.lang.RuntimeException</CODE> - if this method is called on a graph which
 has not had cycles removed via a call to getGraphWithoutCycles.</DL>
</DD>
</DL>
<HR>

<A NAME="getReducedGraph()"><!-- --></A><H3>
getReducedGraph</H3>
<PRE>
public <A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</A> <B>getReducedGraph</B>()</PRE>
<DL>
<DD>Make a graph which is the transitive reduction of the current graph.
 Creates the transitive reduction of the current graph by combining calls
 to getCycleEliminationVertexPriority(), getGraphWithoutCycles(int[]),
 and getReducedGraph(int[]).
<P>
<DD><DL>

<DT><B>Returns:</B><DD>A Graph which is the transitive reduction of the current
 graph.</DL>
</DD>
</DL>
<HR>

<A NAME="orderedSetComparison(int[], int[])"><!-- --></A><H3>
orderedSetComparison</H3>
<PRE>
public static boolean <B>orderedSetComparison</B>(int[]&nbsp;set1,
                                           int[]&nbsp;set2)</PRE>
<DL>
<DD>Compare two sets of integers lexicographically.
 This ordering is used for the Coffman-Graham-Layering algorithm.
 A is less than B if
 <ul><li>A is empty and B is not</li>
 <li>The max element from A is smaller than the max element from B</li>
 <li>A minus its largest element is less than B minus its largest element</li></ul>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>set1</CODE> - an array of unique integers, sorted into descending order<DD><CODE>set2</CODE> - an array of unique integers, sorted into descending order
<DT><B>Returns:</B><DD>true if set1 &lt set2</DL>
</DD>
</DL>
<HR>

<A NAME="getVertexLayers()"><!-- --></A><H3>
getVertexLayers</H3>
<PRE>
public int[] <B>getVertexLayers</B>()</PRE>
<DL>
<DD>Return an array of layer assignments for the nodes.
 This layering is done using the Coffman-Graham-Layering algorithm.
 The algorithm function in two passes:<br>
 In the pass one, every node is labelled with a priority number. This
 labelling is done by iteratively choosing the node whose parents have
 all been labelled, and where the set of parental labels is lexicographically
 less than that of any other node. <br>
 In the second pass, nodes are assigned to layers. Nodes are first added to
 the lowest layer. Nodes are eligible to be added once all of its children
 are assigned to some layer. Nodes cannot be added to the same layer as any
 of its children. Otherwise, nodes are selected from the eligible set by
 taking the one which has the lexicographically greatest set of child node
 labels. Additionally, there is a parameter which sets the maximum width
 of any layer. Once a layer is full, or there are no more valid nodes to
 be added to it, the next higher layer is filled. Once nodes are added to
 the next higher layer, no nodes can be added to any lower layer.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>an integer array containing the per node layer assignment. The
 lowest layer is numbered 1. The next lowest 2, etc.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - if this function is called on a graph which has
 not been reduced by a call to getReducedGraph().</DL>
</DD>
</DL>
<HR>

<A NAME="getHorizontalPosition(int[])"><!-- --></A><H3>
getHorizontalPosition</H3>
<PRE>
public int[] <B>getHorizontalPosition</B>(int[]&nbsp;vertexLayer)</PRE>
<DL>
<DD>Pick Horizontal coordinates within layers for a layered graph.
 The approach is to do two passes of edge crossing reduction. The
 first pass is a hybrid median/barycenter method, and the second
 is an adjacent (within layer) node exchange pass. These algorithms
 are described in Di Battista chapter 9 section 2.<br>
 One significant difference between the algorithms presented and
 this implementation is that when crossings are reduced, the graph
 is not first converted into a proper bipartite graph, nor are dummy
 verticies introduced. Instead, each node is assigned a property value
 representing its xCoordinate. For calculating barycenter and median
 values, these are based on the xCoordinate of all parents in the graph.
 (even those more than one layer away). During the adjacent exchange
 you are also not limited to nodes in adjacent layers.<br>
 The first pass is done from the second from the top layer, and
 moves downward, at each layer examining the parents of each node.
 All nodes are asigned an xCoordinate property. (the top layer gets
 arbitrary values). If more than one node had the same median value,
 they are evenly spaced between that value and the next higher value.<br>
 The second pass is also done from the second from the top layer downward.
 Crossing numbers are not globally computed (no array of crossing numbers
 is constructed). Instead a limited number of fine tuning passes occur
 (default = 5) where local exchanges are considered. For nodes which are
 adjacent in a layer, the parents of each node is put into a list sorted
 by xCoordinate. These parent lists are scaned to determine edge crossings
 in the current and the swapped orientations. Then child nodes are also
 examined, and edge crossings for current and swapped orientation are
 added to those from the parent lists. If total edge crossings are
 reduced, such a swap is done. During swap, the xCoordinate of the nodes
 are exchanged. For the bottom row, only parent nodes are considered.<br>
 In the case of a graph with a single layer, the algorithm is bypassed.<br>
 The return values are integers indicating the order of each layer based on
 xCoordinates of the elements (leftmost = 1).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>vertexLayer</CODE> - a per node layer assignment.
<DT><B>Returns:</B><DD>an array of integers which indicate the horizontal position of each
 node within its assigned layer.
<DT><B>Throws:</B>
<DD><CODE>java.lang.RuntimeException</CODE> - if this function is called on a graph which has
 not been reduced by a call to getReducedGraph().</DL>
</DD>
</DL>
<HR>

<A NAME="main(java.lang.String[])"><!-- --></A><H3>
main</H3>
<PRE>
public static void <B>main</B>(java.lang.String[]&nbsp;args)</PRE>
<DL>
<DD>Read a graph representation from stdin and write out the computed Layer
 assignment and Horizontal position within layer of each node of each
 component.
 For testing only.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>args</CODE> - command line arguments</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Coordinates.html" title="class in org.hypergraphdb.viewer.layout.util"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../org/hypergraphdb/viewer/layout/util/Graph.Edge.html" title="class in org.hypergraphdb.viewer.layout.util"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?org/hypergraphdb/viewer/layout/util/Graph.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Graph.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
