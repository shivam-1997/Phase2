<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_221) on Thu Mar 12 11:20:36 IST 2020 -->
<title>Graph</title>
<meta name="date" content="2020-03-12">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Graph";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":10,"i5":10,"i6":10,"i7":10,"i8":10,"i9":10,"i10":10,"i11":10,"i12":9,"i13":9,"i14":10,"i15":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/hypergraphdb/viewer/layout/util/Coordinates.html" title="class in org.hypergraphdb.viewer.layout.util"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.Edge.html" title="class in org.hypergraphdb.viewer.layout.util"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/hypergraphdb/viewer/layout/util/Graph.html" target="_top">Frames</a></li>
<li><a href="Graph.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.hypergraphdb.viewer.layout.util</div>
<h2 title="Class Graph" class="title">Class Graph</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>org.hypergraphdb.viewer.layout.util.Graph</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">Graph</span>
extends java.lang.Object</pre>
<div class="block">Performs transformations and calculations on graphs.
 This class accepts graphs in an abstract representation. Nodes
 are indexed with integers, beginning with 0. Edges are represented
 with instances of the <code>csplugins.hierarchicallayout.FEdge</code>
 class, which holds a (from, to) pair of integers.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested.class.summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.Edge.html" title="class in org.hypergraphdb.viewer.layout.util">Graph.Edge</a></span></code>
<div class="block">Holds a (from, to) pair of integers representing an edge.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#Graph-int-org.hypergraphdb.viewer.layout.util.Graph.Edge:A-">Graph</a></span>(int&nbsp;a_nodecount,
     <a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.Edge.html" title="class in org.hypergraphdb.viewer.layout.util">Graph.Edge</a>[]&nbsp;a_edge)</code>
<div class="block">Build a graph from a supplied FEdge array.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#Graph-java.io.Reader-">Graph</a></span>(java.io.Reader&nbsp;r)</code>
<div class="block">Build a graph from a stream.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#componentIndex--">componentIndex</a></span>()</code>
<div class="block">Determine node membership in the set of connected components.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getCycleEliminationVertexPriority--">getCycleEliminationVertexPriority</a></span>()</code>
<div class="block">Determine an ordering of nodes used to eliminate cycles.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getEdgecount--">getEdgecount</a></span>()</code>
<div class="block">Accessor.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getGraphWithoutCycles-int:A-">getGraphWithoutCycles</a></span>(int[]&nbsp;cycleEliminationPriority)</code>
<div class="block">Make a graph where all "left" edges are reversed (according to provided node ordering).</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getGraphWithoutMultipleEdges--">getGraphWithoutMultipleEdges</a></span>()</code>
<div class="block">Make a graph which filters out duplicate edges.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getGraphWithoutOneOrTwoCycles--">getGraphWithoutOneOrTwoCycles</a></span>()</code>
<div class="block">Make a graph which filters out short (length 1 or 2) cycles.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getHorizontalPosition-int:A-">getHorizontalPosition</a></span>(int[]&nbsp;vertexLayer)</code>
<div class="block">Pick Horizontal coordinates within layers for a layered graph.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getNodecount--">getNodecount</a></span>()</code>
<div class="block">Accessor.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getReducedGraph--">getReducedGraph</a></span>()</code>
<div class="block">Make a graph which is the transitive reduction of the current graph.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getReducedGraph-int:A-">getReducedGraph</a></span>(int[]&nbsp;topologicalOrder)</code>
<div class="block">Make a graph which is the transitive reduction of the current graph.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#getVertexLayers--">getVertexLayers</a></span>()</code>
<div class="block">Return an array of layer assignments for the nodes.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#hasEdge-int-int-">hasEdge</a></span>(int&nbsp;edgeFrom,
       int&nbsp;edgeTo)</code>
<div class="block">Query to test whether an edge exists.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#main-java.lang.String:A-">main</a></span>(java.lang.String[]&nbsp;args)</code>
<div class="block">Read a graph representation from stdin and write out the computed Layer
 assignment and Horizontal position within layer of each node of each
 component.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>static boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#orderedSetComparison-int:A-int:A-">orderedSetComparison</a></span>(int[]&nbsp;set1,
                    int[]&nbsp;set2)</code>
<div class="block">Compare two sets of integers lexicographically.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</a>[]</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#partition-int:A-int:A-">partition</a></span>(int[]&nbsp;partitionIndex,
         int[]&nbsp;nodeRenumber)</code>
<div class="block">Create an array of Graphs by partitioning this graph.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html#toString--">toString</a></span>()</code>
<div class="block">Human readable description of graph representation.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Graph-int-org.hypergraphdb.viewer.layout.util.Graph.Edge:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>Graph</h4>
<pre>public&nbsp;Graph(int&nbsp;a_nodecount,
             <a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.Edge.html" title="class in org.hypergraphdb.viewer.layout.util">Graph.Edge</a>[]&nbsp;a_edge)</pre>
<div class="block">Build a graph from a supplied FEdge array.
 Nodes must be consecutively indexed beginning with zero.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>a_nodecount</code> - The total number of nodes in the graph</dd>
<dd><code>a_edge</code> - An array of all edges in the graph (each edge holds the source and destination node's indicies)</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - If any edge refers to an out of range node</dd>
</dl>
</li>
</ul>
<a name="Graph-java.io.Reader-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Graph</h4>
<pre>public&nbsp;Graph(java.io.Reader&nbsp;r)
      throws java.io.IOException</pre>
<div class="block">Build a graph from a stream.
 The input stream will be read and parsed in the following format:
 On the first line is an integer indicating the number of nodes in the graph.
 This is followed by one line per edge containing two integers: the edge
 source (where nodes are indexed sequentially starting from zero), and the
 edge destination. These two values are spearated by whitespace. Then there
 is a terminal line containing only a period character "." <br>
 Unavailable or badly formed files will cause exceptions to be thrown
 (including NumberFormatExceptions)</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>r</code> - The reader of the input stream from which to read the graph data.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.io.IOException</code> - if trouble is encountered reading the file</dd>
<dd><code>java.lang.NumberFormatException</code> - if any value in the input does not parse to an integer</dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="toString--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre>public&nbsp;java.lang.String&nbsp;toString()</pre>
<div class="block">Human readable description of graph representation. Prints a node count line
 followed by the edge endpoint (one per line).</div>
<dl>
<dt><span class="overrideSpecifyLabel">Overrides:</span></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Human readable graph description in string form</dd>
</dl>
</li>
</ul>
<a name="getNodecount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getNodecount</h4>
<pre>public&nbsp;int&nbsp;getNodecount()</pre>
<div class="block">Accessor.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>total number of nodes in graph</dd>
</dl>
</li>
</ul>
<a name="getEdgecount--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getEdgecount</h4>
<pre>public&nbsp;int&nbsp;getEdgecount()</pre>
<div class="block">Accessor.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>total number of edges in graph</dd>
</dl>
</li>
</ul>
<a name="hasEdge-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasEdge</h4>
<pre>public&nbsp;boolean&nbsp;hasEdge(int&nbsp;edgeFrom,
                       int&nbsp;edgeTo)</pre>
<div class="block">Query to test whether an edge exists.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>edgeFrom</code> - node index for the origin</dd>
<dd><code>edgeTo</code> - node index for the destination</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>True if the queried edge is in the graph</dd>
</dl>
</li>
</ul>
<a name="getGraphWithoutOneOrTwoCycles--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGraphWithoutOneOrTwoCycles</h4>
<pre>public&nbsp;<a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</a>&nbsp;getGraphWithoutOneOrTwoCycles()</pre>
<div class="block">Make a graph which filters out short (length 1 or 2) cycles.
 Generates a new graph object which is the same is the current graph except
 that all edges which begin and end at the same node (loops) or edges which
 are an inverted instance of some other edge in the graph (a,b); (b,a)
 are filtered out.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a graph without cycles of length one or edges which used to
 be part of a cycle of length two.</dd>
</dl>
</li>
</ul>
<a name="getGraphWithoutMultipleEdges--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGraphWithoutMultipleEdges</h4>
<pre>public&nbsp;<a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</a>&nbsp;getGraphWithoutMultipleEdges()</pre>
<div class="block">Make a graph which filters out duplicate edges.
 Generates a new graph object which is the same is the current graph except
 that if there are several duplicate edges (same source and target), all
 but one of each set of duplicates is filtered out.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a graph without duplicate edges</dd>
</dl>
</li>
</ul>
<a name="componentIndex--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>componentIndex</h4>
<pre>public&nbsp;int[]&nbsp;componentIndex()</pre>
<div class="block">Determine node membership in the set of connected components.
 Components are detected and numbered. Each node is assigned an integer number
 which corresponds to the component which it is a member of. Components are
 numbered consecutively, beginning with 0. These numbers are returned in an
 array, whose length is equal to nodecount.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An array of integer component numbers - one for each node in this graph.</dd>
</dl>
</li>
</ul>
<a name="partition-int:A-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>partition</h4>
<pre>public&nbsp;<a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</a>[]&nbsp;partition(int[]&nbsp;partitionIndex,
                         int[]&nbsp;nodeRenumber)</pre>
<div class="block">Create an array of Graphs by partitioning this graph.
 This method takes an array of integers equal in length to nodecount.
 Each element of the array specifies which subgraph the corresponding
 node should belong to. Subgraphs are numbered beginning with zero.
 Every node is put in exactly one subgraph, and
 the set of subgraphs are returned. The index number of each node is
 recalculated as it is added to its subgraph. This renumbering is returned
 in an array passed in as an argument (nodeRenumber). The elements of
 this array will hold the new index number of each node as it appears
 in its corresponding subgraph.<br>
 Edges' source and destination values are modified to maintain the
 appropriate topology. Edges which span different subgraphs are
 deleted.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>partitionIndex</code> - A subgraph index for each node in the graph.</dd>
<dd><code>nodeRenumber</code> - An array which is passed back to the caller
 containing the new index number of each node as it sits in its
 subgraph.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An array of graphs containing the nodes directed to each
 subgraph according to the indicies in partitionIndex.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the size of either argument
 array is incorrect (!= nodecount)</dd>
</dl>
</li>
</ul>
<a name="getCycleEliminationVertexPriority--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getCycleEliminationVertexPriority</h4>
<pre>public&nbsp;int[]&nbsp;getCycleEliminationVertexPriority()</pre>
<div class="block">Determine an ordering of nodes used to eliminate cycles.
 This is an implementation of the "Greedy-Cycle-Removal"
 algorithm presented by Sugiyama et al. in chapter 9 of
 "Graph Drawing" by Di Battista et al. <br>
 The basic appraach is that all nodes are examined and
 nodes which are sinks are removed from the graph and
 added to the end of the order, and nodes which are
 sources are removed and added to the beginning of the
 order. If there are no sources or sinks, the node with
 the greatest difference between outgoing and incoming
 edges is added to the beginning of the list. Removing
 nodes from the graph creates new sources and sinks,
 and through iteration an order is computed. <br>
 Note: during this computation, nodes are removed from
 a temporary copy of the graph; no change happens to
 the current graph. Also, the temporary copy is filtered
 of short cycles (length 1 or 2 cycles) and transitive
 edges.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>An array of integers which represents an ordered list
 of nodes. The elements which are closer to the beginning of the
 array are indecies of nodes which are more "sourcelike". Those
 closer to the end of the array are more "sinklike". The intention
 is that this ordering will be used to eliminate cycles by reversing
 the direction of any edges which oppose the implied flow from
 sources to sinks.</dd>
</dl>
</li>
</ul>
<a name="getGraphWithoutCycles-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getGraphWithoutCycles</h4>
<pre>public&nbsp;<a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</a>&nbsp;getGraphWithoutCycles(int[]&nbsp;cycleEliminationPriority)</pre>
<div class="block">Make a graph where all "left" edges are reversed (according to provided node ordering).
 A left edge is one which begins at a node which is later
 in the provided order than the edge's destination.
 A new Graph object which is thereby free of cycles is
 returned.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>cycleEliminationPriority</code> - an ordering of node indecies.
 Nodes near the beginning are considered more "sourcelike",
 while those towards the end are condiered more "sinklike".</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A Graph which is similar to the current graph, but
 which has no cycles due to the reversal of left edges.</dd>
</dl>
</li>
</ul>
<a name="getReducedGraph-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getReducedGraph</h4>
<pre>public&nbsp;<a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</a>&nbsp;getReducedGraph(int[]&nbsp;topologicalOrder)</pre>
<div class="block">Make a graph which is the transitive reduction of the current graph.
 A transitive edge is one where some other path exists from the
 edge's source to its destination. Using the provided topological
 ordedring of nodes, this method efficiently preforms the reduction.
 The heart of the algorithm is that at each node, the child which
 has the highest position in the topological order cannot be a
 transitive edge. If we know the list of descendants of that child,
 then we know if the second child (in the topological order) is
 connected by a transitive edge or not. By recursively updating
 the lists of descendants of a node, this process continues until
 all children are examined, at which point we know the full list
 of the examined node's descendants, which can be passeed up to
 the node's parents, allowing the recursion. <br>
 Note: this method can only be called on a graph which is acyclic,
 otherwise a RuntimeException is thrown.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>topologicalOrder</code> - an ordering of node indecies such that
 there are no edges from a node lower in the order to a node higher
 in the ordedr.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A Graph which is the transitive reduction of the current
 graph.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalArgumentException</code> - if the size of topological order
 is not equal to nodecount.</dd>
<dd><code>java.lang.RuntimeException</code> - if this method is called on a graph which
 has not had cycles removed via a call to getGraphWithoutCycles.</dd>
</dl>
</li>
</ul>
<a name="getReducedGraph--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getReducedGraph</h4>
<pre>public&nbsp;<a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.html" title="class in org.hypergraphdb.viewer.layout.util">Graph</a>&nbsp;getReducedGraph()</pre>
<div class="block">Make a graph which is the transitive reduction of the current graph.
 Creates the transitive reduction of the current graph by combining calls
 to getCycleEliminationVertexPriority(), getGraphWithoutCycles(int[]),
 and getReducedGraph(int[]).</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A Graph which is the transitive reduction of the current
 graph.</dd>
</dl>
</li>
</ul>
<a name="orderedSetComparison-int:A-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orderedSetComparison</h4>
<pre>public static&nbsp;boolean&nbsp;orderedSetComparison(int[]&nbsp;set1,
                                           int[]&nbsp;set2)</pre>
<div class="block">Compare two sets of integers lexicographically.
 This ordering is used for the Coffman-Graham-Layering algorithm.
 A is less than B if
 <ul><li>A is empty and B is not</li>
 <li>The max element from A is smaller than the max element from B</li>
 <li>A minus its largest element is less than B minus its largest element</li></ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>set1</code> - an array of unique integers, sorted into descending order</dd>
<dd><code>set2</code> - an array of unique integers, sorted into descending order</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>true if set1 &lt set2</dd>
</dl>
</li>
</ul>
<a name="getVertexLayers--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getVertexLayers</h4>
<pre>public&nbsp;int[]&nbsp;getVertexLayers()</pre>
<div class="block">Return an array of layer assignments for the nodes.
 This layering is done using the Coffman-Graham-Layering algorithm.
 The algorithm function in two passes:<br>
 In the pass one, every node is labelled with a priority number. This
 labelling is done by iteratively choosing the node whose parents have
 all been labelled, and where the set of parental labels is lexicographically
 less than that of any other node. <br>
 In the second pass, nodes are assigned to layers. Nodes are first added to
 the lowest layer. Nodes are eligible to be added once all of its children
 are assigned to some layer. Nodes cannot be added to the same layer as any
 of its children. Otherwise, nodes are selected from the eligible set by
 taking the one which has the lexicographically greatest set of child node
 labels. Additionally, there is a parameter which sets the maximum width
 of any layer. Once a layer is full, or there are no more valid nodes to
 be added to it, the next higher layer is filled. Once nodes are added to
 the next higher layer, no nodes can be added to any lower layer.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an integer array containing the per node layer assignment. The
 lowest layer is numbered 1. The next lowest 2, etc.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if this function is called on a graph which has
 not been reduced by a call to getReducedGraph().</dd>
</dl>
</li>
</ul>
<a name="getHorizontalPosition-int:A-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getHorizontalPosition</h4>
<pre>public&nbsp;int[]&nbsp;getHorizontalPosition(int[]&nbsp;vertexLayer)</pre>
<div class="block">Pick Horizontal coordinates within layers for a layered graph.
 The approach is to do two passes of edge crossing reduction. The
 first pass is a hybrid median/barycenter method, and the second
 is an adjacent (within layer) node exchange pass. These algorithms
 are described in Di Battista chapter 9 section 2.<br>
 One significant difference between the algorithms presented and
 this implementation is that when crossings are reduced, the graph
 is not first converted into a proper bipartite graph, nor are dummy
 verticies introduced. Instead, each node is assigned a property value
 representing its xCoordinate. For calculating barycenter and median
 values, these are based on the xCoordinate of all parents in the graph.
 (even those more than one layer away). During the adjacent exchange
 you are also not limited to nodes in adjacent layers.<br>
 The first pass is done from the second from the top layer, and
 moves downward, at each layer examining the parents of each node.
 All nodes are asigned an xCoordinate property. (the top layer gets
 arbitrary values). If more than one node had the same median value,
 they are evenly spaced between that value and the next higher value.<br>
 The second pass is also done from the second from the top layer downward.
 Crossing numbers are not globally computed (no array of crossing numbers
 is constructed). Instead a limited number of fine tuning passes occur
 (default = 5) where local exchanges are considered. For nodes which are
 adjacent in a layer, the parents of each node is put into a list sorted
 by xCoordinate. These parent lists are scaned to determine edge crossings
 in the current and the swapped orientations. Then child nodes are also
 examined, and edge crossings for current and swapped orientation are
 added to those from the parent lists. If total edge crossings are
 reduced, such a swap is done. During swap, the xCoordinate of the nodes
 are exchanged. For the bottom row, only parent nodes are considered.<br>
 In the case of a graph with a single layer, the algorithm is bypassed.<br>
 The return values are integers indicating the order of each layer based on
 xCoordinates of the elements (leftmost = 1).</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>vertexLayer</code> - a per node layer assignment.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>an array of integers which indicate the horizontal position of each
 node within its assigned layer.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.RuntimeException</code> - if this function is called on a graph which has
 not been reduced by a call to getReducedGraph().</dd>
</dl>
</li>
</ul>
<a name="main-java.lang.String:A-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>main</h4>
<pre>public static&nbsp;void&nbsp;main(java.lang.String[]&nbsp;args)</pre>
<div class="block">Read a graph representation from stdin and write out the computed Layer
 assignment and Horizontal position within layer of each node of each
 component.
 For testing only.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>args</code> - command line arguments</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../../org/hypergraphdb/viewer/layout/util/Coordinates.html" title="class in org.hypergraphdb.viewer.layout.util"><span class="typeNameLink">Prev&nbsp;Class</span></a></li>
<li><a href="../../../../../org/hypergraphdb/viewer/layout/util/Graph.Edge.html" title="class in org.hypergraphdb.viewer.layout.util"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../../index.html?org/hypergraphdb/viewer/layout/util/Graph.html" target="_top">Frames</a></li>
<li><a href="Graph.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested.class.summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
